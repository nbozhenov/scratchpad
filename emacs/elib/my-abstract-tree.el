;; -*- lexical-binding: t -*-

;; Большинство итераторов в данном модуле могут принимать как унарные, так и бинарные
;; функции в качестве агрументов. Предполагается, что унарные функции в качестве
;; аргумента принимают только содержимое (content) ноды, а бинарные дополнительно
;; вторым аргументом принимают еще и саму ноду.
;; Исключения --- abstract-tree-build, который всегда передает ноду, т.к. это
;;                максимально обобщенный итератор, который в общем случае обходит
;;                деревья произвольного типа.
;;            --- итераторы, в имени которых есть content или node; в таком случае
;;                из их имени должно быть ясно, что будет передано функции в качестве
;;                аргумента.

(require 'cl)
(require 'y-harness)
(require 'y-hs)

;; Пустое дерево --- это nil
;; Необходимо корректно работать, когда приходит nil вместо дерева
(defstruct abstract-tree parent content plist children)

(defun abstract-tree-build (original &optional get-children transform predicate make-plist)
  "Натягиваем новое дерево поверх старого (ORIGINAL).
GET-CHILDREN --- функция, достающая поддеревья из ORIGINAL
по умолчанию --- abstract-tree-children.
TRANSFORM --- функция, преобразующая оригинальную ноду.
PREDICATE --- условие, которому должна удовлетворять нода оригинального дерева,
чтобы быть отраженной в новом дереве.
MAKE-PLIST : nil  { no plist in new tree }
           | copy { copy plist from old node }
           | func1 { plist is generated by (funcall func1 old-node) }

NB: Если не принимать специальных мер, то в свежепостроенном дереве у корня
parent будет nil. Такое поведение нежелательно для, например, `abstract-tree-copy'
или `abstract-tree-filter'."
  (let ((get-children   (or get-children 'abstract-tree-children))
        (transform      (or transform 'identity))
        (predicate      (or predicate (lambda (x) t)))
        (make-plist     (cond
                         ((eq nil make-plist) (lambda (x) nil))
                         ((eq 'copy make-plist) (lambda (x) (copy-list (abstract-tree-plist x))))
                         (t make-plist)))
        retval)

    (when (and original (funcall predicate original))
      (setq retval (make-abstract-tree :content (funcall transform original)
                                       :plist (funcall make-plist original)))
      (setf (abstract-tree-children retval)
            (mapcar (lambda (x) (setf (abstract-tree-parent x) retval)
                      x)
                    (y-filter 'identity
                              (mapcar (lambda (x) (abstract-tree-build x get-children transform
                                                                       predicate make-plist))
                                      (funcall get-children original)))))
      retval)))

(defun abstract-tree-copy (tree)
  "Полное копирование структуры дерева,
включая создание копии plist-а для каждой ноды и наследование parent-а для корня дерева."
  (let ((retval (abstract-tree-build tree nil 'abstract-tree-content nil 'copy)))
    (when retval
      (setf (abstract-tree-parent retval) (abstract-tree-parent tree)))
    retval))

(defun abstract-tree-size (tree)
  (if tree
      (y-foldl (lambda (m x) (+ m (abstract-tree-size x)))
               1
               (abstract-tree-children tree))
    0))

(defsubst abstract-tree-attach-in-place (tree node)
  "Attach NODE to TREE as a new child.
Modifies both TREE and NODE."
  (setf (abstract-tree-children tree)
        (append (abstract-tree-children tree) (and node (list node))))
  (when node
    (setf (abstract-tree-parent node) tree))
  tree)

(defsubst abstract-tree-attach (tree node)
  (abstract-tree-attach-in-place (abstract-tree-copy tree)
                                 (abstract-tree-copy node)))

(defun abstract-tree-put (tree prop value)
  "return value unspecified"
  (setf (abstract-tree-plist tree)
        (plist-put (abstract-tree-plist tree) prop value)))

(defun abstract-tree-get (tree prop)
  (plist-get (abstract-tree-plist tree) prop))
  
(defun abstract-tree-walk (tree func &optional predicate)
  "Вызывает FUNC для каждой структуры abstract-tree в дереве.
Обход дерева осуществляется в глубину, сверху вниз.
Если для текущей ноды TREE функция FUNC изменяет порядок или количество
дочерних нод, то при рекурсивном вызове будет использован новый список
дочерних узлов.
return value unspecified."
  (when tree
    (when (or (not predicate)
              (abstract-tree-apply predicate tree))
      (abstract-tree-apply func tree))
    (mapc (lambda (x) (abstract-tree-walk x func predicate))
          (abstract-tree-children tree))))

(defun abstract-tree-map (tree func)
  (abstract-tree-build tree nil (lambda (x) (abstract-tree-apply func x))))

(defun abstract-tree-filter (tree predicate)
  (let ((retval (abstract-tree-build tree nil 'abstract-tree-content
                                     (lambda (x) (abstract-tree-apply predicate x))
                                     'copy)))
    (when retval
      (setf (abstract-tree-parent retval) (abstract-tree-parent tree)))
    retval))

(defun abstract-tree-find-children (tree predicate)
  "Возвращает список всех дочерних нод для TREE, удовлетворяющих условию PREDICATE."
  (let (retval)
    (abstract-tree-walk tree (lambda (x y) (when (abstract-tree-apply predicate y)
                                             (push y retval))))
    (nreverse retval)))

(defun abstract-tree-find-first (tree predicate)
  (catch 'abstract-tree-find-first
    (abstract-tree-walk tree (lambda (x y) (when (abstract-tree-apply predicate y)
                                             (throw 'abstract-tree-find-first y))))
    nil))

(defun abstract-tree-find-ancestor--internal (tree predicate)
  (if (abstract-tree-apply predicate tree)
      tree
    (abstract-tree-find-ancestor tree predicate)))

(defun abstract-tree-find-ancestor (tree predicate)
  "Возвращает наиболее близкого предка, удовлетворяющего условию PREDICATE.
Следующего предка можно найти повторным вызовом функции, используя результат первого вызова."
  (let ((parent (and tree (abstract-tree-parent tree))))
    (when parent
      (abstract-tree-find-ancestor--internal parent predicate))))

(defun abstract-tree-map-up (tree func)
  (when tree
    (cons (abstract-tree-apply func tree)
          (abstract-tree-map-up (abstract-tree-parent tree) func))))

(defun abstract-tree-apply (func tree)
  (if (cadr (help-function-arglist func))
      (funcall func (abstract-tree-content tree) tree)
    (funcall func (abstract-tree-content tree))))

(provide 'my-abstract-tree)
